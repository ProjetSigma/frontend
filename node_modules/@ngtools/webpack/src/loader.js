"use strict";
var path = require('path');
var ts = require('typescript');
var plugin_1 = require('./plugin');
var ast_tools_1 = require('@angular-cli/ast-tools');
// TODO: move all this to ast-tools.
function _findNodes(sourceFile, node, kind, keepGoing) {
    if (keepGoing === void 0) { keepGoing = false; }
    if (node.kind == kind && !keepGoing) {
        return [node];
    }
    return node.getChildren(sourceFile).reduce(function (result, n) {
        return result.concat(_findNodes(sourceFile, n, kind, keepGoing));
    }, node.kind == kind ? [node] : []);
}
function _removeDecorators(fileName, source) {
    var sourceFile = ts.createSourceFile(fileName, source, ts.ScriptTarget.Latest);
    // Find all decorators.
    var decorators = _findNodes(sourceFile, sourceFile, ts.SyntaxKind.Decorator);
    decorators.sort(function (a, b) { return b.pos - a.pos; });
    decorators.forEach(function (d) {
        source = source.slice(0, d.pos) + source.slice(d.end);
    });
    return source;
}
function _replaceBootstrap(fileName, source, plugin) {
    // If bootstrapModule can't be found, bail out early.
    if (!source.match(/\bbootstrapModule\b/)) {
        return Promise.resolve(source);
    }
    var changes = new ast_tools_1.MultiChange();
    // Calculate the base path.
    var basePath = path.normalize(plugin.angularCompilerOptions.basePath);
    var genDir = path.normalize(plugin.genDir);
    var dirName = path.normalize(path.dirname(fileName));
    var _a = plugin.entryModule.split('#'), entryModulePath = _a[0], entryModuleName = _a[1];
    var entryModuleFileName = path.normalize(entryModulePath + '.ngfactory');
    var relativeEntryModulePath = path.relative(basePath, entryModuleFileName);
    var fullEntryModulePath = path.resolve(genDir, relativeEntryModulePath);
    var relativeNgFactoryPath = path.relative(dirName, fullEntryModulePath);
    var ngFactoryPath = './' + relativeNgFactoryPath.replace(/\\/g, '/');
    var sourceFile = ts.createSourceFile(fileName, source, ts.ScriptTarget.Latest);
    var allCalls = _findNodes(sourceFile, sourceFile, ts.SyntaxKind.CallExpression, true);
    var bootstraps = allCalls
        .filter(function (call) { return call.expression.kind == ts.SyntaxKind.PropertyAccessExpression; })
        .map(function (call) { return call.expression; })
        .filter(function (access) {
        return access.name.kind == ts.SyntaxKind.Identifier
            && access.name.text == 'bootstrapModule';
    });
    var calls = bootstraps
        .reduce(function (previous, access) {
        return previous.concat(_findNodes(sourceFile, access, ts.SyntaxKind.CallExpression, true));
    }, [])
        .filter(function (call) {
        return call.expression.kind == ts.SyntaxKind.Identifier
            && call.expression.text == 'platformBrowserDynamic';
    });
    if (calls.length == 0) {
        // Didn't find any dynamic bootstrapping going on.
        return Promise.resolve(source);
    }
    // Create the changes we need.
    allCalls
        .filter(function (call) { return bootstraps.some(function (bs) { return bs == call.expression; }); })
        .forEach(function (call) {
        changes.appendChange(new ast_tools_1.ReplaceChange(fileName, call.arguments[0].getStart(sourceFile), entryModuleName, entryModuleName + 'NgFactory'));
    });
    calls
        .forEach(function (call) {
        changes.appendChange(new ast_tools_1.ReplaceChange(fileName, call.getStart(sourceFile), 'platformBrowserDynamic', 'platformBrowser'));
    });
    bootstraps
        .forEach(function (bs) {
        // This changes the call.
        changes.appendChange(new ast_tools_1.ReplaceChange(fileName, bs.name.getStart(sourceFile), 'bootstrapModule', 'bootstrapModuleFactory'));
    });
    changes.appendChange(ast_tools_1.insertImport(fileName, 'platformBrowser', '@angular/platform-browser'));
    changes.appendChange(ast_tools_1.insertImport(fileName, entryModuleName + 'NgFactory', ngFactoryPath));
    var sourceText = source;
    return changes.apply({
        read: function (path) { return Promise.resolve(sourceText); },
        write: function (path, content) { return Promise.resolve(sourceText = content); }
    }).then(function () { return sourceText; });
}
// Super simple TS transpiler loader for testing / isolated usage. does not type check!
function ngcLoader(source) {
    var _this = this;
    this.cacheable();
    var plugin = this._compilation._ngToolsWebpackPluginInstance;
    if (plugin && plugin instanceof plugin_1.NgcWebpackPlugin) {
        var cb_1 = this.async();
        plugin.done
            .then(function () { return _removeDecorators(_this.resource, source); })
            .then(function (sourceText) { return _replaceBootstrap(_this.resource, sourceText, plugin); })
            .then(function (sourceText) {
            var result = ts.transpileModule(sourceText, {
                compilerOptions: {
                    target: ts.ScriptTarget.ES5,
                    module: ts.ModuleKind.ES2015,
                }
            });
            if (result.diagnostics && result.diagnostics.length) {
                var message_1 = '';
                result.diagnostics.forEach(function (d) {
                    message_1 += d.messageText + '\n';
                });
                cb_1(new Error(message_1));
            }
            cb_1(null, result.outputText, result.sourceMapText ? JSON.parse(result.sourceMapText) : null);
        })
            .catch(function (err) { return cb_1(err); });
    }
    else {
        return ts.transpileModule(source, {
            compilerOptions: {
                target: ts.ScriptTarget.ES5,
                module: ts.ModuleKind.ES2015,
            }
        }).outputText;
    }
}
exports.ngcLoader = ngcLoader;
//# sourceMappingURL=/Users/hansl/Sources/angular-cli/packages/webpack/src/loader.js.map